<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/js/tokenizer.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/CourseCodeTokenizer.html">CourseCodeTokenizer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: public/js/tokenizer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

//the school tokens are:
	//SE: school of engineering
	//AS: arts and science
	//PB: peabody
	//BL: Blair

//is this script being run on server or client side

var serverSide = typeof require === &#x27;function&#x27; &amp;&amp; typeof exports === &#x27;object&#x27; &amp;&amp; typeof module === &#x27;object&#x27;;
if (serverSide) {
	var _ = require(&#x27;underscore&#x27;);
}


/**
 * Parses course codes into tokens that can be
 * interpretted by higher level functions.  Also offers
 * low-level comparisons of token objects.  THIS CLASS
 * SHOULD NEVER BE CALLED DIRECTLY.
 * @class CourseCodeTokenizer
 */
var CourseCodeTokenizer = {
	
	/**
	 * Compares course code strings for equality.  This goes
	 * beyond string comparison; compares if the course codes are
	 * referring to the same type of course, whether it is a single
	 * course or multiple courses
	 * @method isEqual
	 * @param courseCode1 Course code as a string
	 * @param courseCode2 Course code as a string
	 */
	isEqual: function(courseCode1, courseCode2) {
		var token1 = CourseCodeTokenizer.parse(courseCode1),
			token2 = CourseCodeTokenizer.parse(courseCode2);

		return _.isEqual(token1, token2);
	},
	parse: function(courseCode) {

		var validSchoolTokens,
			matchSchoolToken,
			token = {},
		    q = courseCode.match(/[+,$,*,~,^]$/);
		    if (q) {
		    	token.query = q[0];
		    }
		    //check for the anti character at the beginning
		    if (courseCode.charAt(0) === &quot;!&quot;) {
		    	token.not = true;
		    	courseCode = courseCode.substr(1, courseCode.length - 1);
		    } else {
		    	token.not = false;
		    }

		if (!token.query) {
			
			//then the Statement is just a normal course code
			token.coursePrefix = courseCode.match(/^[a-z]+/i)[0].toUpperCase();
			token.courseNumber = +courseCode.match(/\d+/)[0];
			if (courseCode.match(/[a-z]+$/i)) {
				token.courseSuffix = courseCode.match(/[a-z]+$/i)[0].toUpperCase();
			}

		} else if (token.query === &#x27;$&#x27;) {
			token.courseSuffix = courseCode.match(/^[a-z]+/i)[0].toUpperCase();
			
			
		} else if (token.query === &#x27;+&#x27;) {
			if (courseCode.match(/\d+/)) {
				token.courseNumber = +courseCode.match(/\d+/)[0];
			} else {
				token.courseNumber = 0;
			}	
			token.coursePrefix = courseCode.match(/^[a-z]+/i)[0].toUpperCase();

		} else if (token.query === &#x27;~&#x27;) {
			token.category = courseCode.match(/^[a-z]+/i)[0].toUpperCase();

		} else if (token.query === &#x27;^&#x27;) {
			validSchoolTokens = [&#x27;SE&#x27;, &#x27;PB&#x27;, &#x27;BL&#x27;, &#x27;AS&#x27;];
			token.school = courseCode.match(/^[a-z]+/i)[0].toUpperCase();
			matchSchoolToken = false;
			validSchoolTokens.forEach(function(sToken) {
				if (sToken == token.school) {
					matchSchoolToken = true;
				}
			});

			if (!matchSchoolToken) {
				throw new Error(&quot;invalid school token &quot; + token.school);
			}


		} else {
			token.coursePrefix = courseCode.match(/^[a-z]+/i)[0].toUpperCase();
			
		}

		return token;

	},
	//returns true if the courseCode is within the Statement
	//automatically returns false if the course code parameter
	//is filled with a quey (something with a Statement character, like +)
	matchQuery: function(courseCode, query) {
		var token = CourseCodeTokenizer.parse(query),
		    codeObject = CourseCodeTokenizer.parse(courseCode);

		return CourseCodeTokenizer.matchObject(codeObject, token);
		
	},
	matchObject: function(codeObject, token) {
		var negateStatement;
		if (!token.query) {
			negateStatement = CourseCodeTokenizer.copyToken(token);
			negateStatement.not = false;
			return (!token.not &amp;&amp; _.isEqual(codeObject, token)) || (token.not &amp;&amp; !_.isEqual(codeObject, negateStatement));

		} else if (token.query === &#x27;$&#x27;) {

			return (!token.not &amp;&amp; token.courseSuffix === codeObject.courseSuffix) || (token.not &amp;&amp; token.courseSuffix !== codeObject.courseSuffix);

		} else if (token.query === &#x27;*&#x27;) {

			return (!token.not &amp;&amp; token.coursePrefix === codeObject.coursePrefix) || (token.not &amp;&amp; token.coursePrefix !== codeObject.coursePrefix);

		} else if (token.query === &#x27;+&#x27;) {

			return (!token.not &amp;&amp; (token.coursePrefix === codeObject.coursePrefix &amp;&amp; codeObject.courseNumber &gt;= token.courseNumber)) 
					|| (token.not &amp;&amp; (token.coursePrefix !== codeObject.coursePrefix || codeObject.courseNumber &lt; token.courseNumber));

		} else if (token.query === &#x27;^&#x27;) {
			throw new Error(&quot;cannot match a statement to the school (^) token&quot;);
		} else if (token.query === &quot;~&quot;) {
			throw new Error(&quot;cannot match a statement with the category (~) token&quot;);
		}

		return false;
	},
	
	//makes a deep copy and returns it
	copyToken: function(obj) {
		var copy = {}, i;
		for (i in obj) {
			if (obj.hasOwnProperty(i)) {
				//nothing is nested in a Statement object,
				// no recursion needed
				copy[i] = obj[i];
			}
		}
		return copy;
	}	
};


//USE THIS CONSTRUCTOR HERE TO CONSTRUCT A Statement
function Statement(statementString) {
	var tokens = statementString.split(&quot;&amp;&quot;);
	this.tokens = tokens.map(function(token) {
		token = token.trim();
		return CourseCodeTokenizer.parse(token);
	});
};

Statement.prototype.has = function(courseCode) {
	var i, n;
	if (this.isSingleStatement()) {
		return CourseCodeTokenizer.matchQuery(courseCode, this.toString());
	} else {
		for (i =0, n = this.tokens.length; i &lt; n; ++i) {
			if (!CourseCodeTokenizer.matchQuery(courseCode, Statement.formatObject(this.tokens[i]))) {
				return false;
			}
		}
		return true;
	}
};
//takes an array of course codes and returns another array of
//course codes with the codes that do not match 
//the Statement filtered out
Statement.prototype.filter = function(courseCodeArray) {
	var has = this.has.bind(this);
	return courseCodeArray.filter(function(courseCode) {
		return has(courseCode);
	}).map(function(courseCode) {
		return Statement.formatStatement(courseCode);
	});
};

//adds an &quot;and&quot; Statement
//can be a Statement object or a course code
Statement.prototype.and = function(statement) {
	this.tokens.push(CourseCodeTokenizer.parse(statement));
};

//returns true if the Statement is equal to the course code
Statement.prototype.isEqual = function(statement) {
	var statementCopy, i,j, n;
	if (this === statement) {return true;}

	if (typeof statement === &#x27;string&#x27;) {
		return this.isEqual(new Statement(statement));
	} else if (typeof statement === &#x27;object&#x27; &amp;&amp; statement.constructor === Statement) {
		
		if (this.tokens.length === statement.tokens.length) {
			
			statementCopy = statement.tokens.slice();
			for (i = 0, n = this.tokens.length; i &lt; n; ++i) {
				
				for (j = 0; j &lt; n; ++j) {
					//null out any tokens that match in both arrays
					if (_.isEqual(this.tokens[i], statementCopy[j])) {
						statementCopy[j] = null;
					}
				}
			}
			return !statementCopy.filter(function(token) {return token;}).length;
		}
	}
	return false;
};

//true if the Statement is just a single course code
Statement.prototype.isSingleCourse = function() {
	return this.isSingleStatement &amp;&amp; !this.tokens[0].query;
};

//true if the Statement is not an ampersand combo Statement
Statement.prototype.isSingleStatement = function() {
	return this.tokens.length === 1
};

Statement.prototype.isNegated = function() {
	return this.isSingleStatement() &amp;&amp; this.tokens[0].not;
};

Statement.prototype.toString = function() {
	var queries = this.tokens.map(function(statement) {
		return Statement.formatObject(statement);
	});
	return queries.join(&quot; &amp; &quot;);
};

//makes a deep copy and returns the copy
Statement.prototype.copy = function() {
	return new Statement(this.toString());
};

//static methods

//reformats the Statement string and returns another
//Statement string in the new format (capitalization, proper spacing, etc)
Statement.formatStatement = function(statementString) {
	var statements = statementString.split(&quot;&amp;&quot;).map(function(statement) {
		var obj = CourseCodeTokenizer.parse(statement.trim());
		return Statement.formatObject(obj);
	});
	return statements.join(&quot; &amp; &quot;);
};

Statement.isEqual = function(statementString1, statementString2) {
	var statement1 = new Statement(statementString1),
		statement2 = new Statement(statementString2);
	return statement1.isEqual(statement2);
};

//should not call these methods, they are &quot;private&quot;

//converts a Statement object to a Statement string
//this is for formatting a single Statement
Statement.formatObject = function(obj) {
	var format;

	if (obj.not) {
		format = &quot;!&quot;;
	} else {
		format = &quot;&quot;;
	}
	if (!obj.query) {
		format = format + obj.coursePrefix.toUpperCase() + &quot; &quot;;
		format = format + obj.courseNumber.toString();
		if (obj.courseSuffix) {
			format = format + obj.courseSuffix.toUpperCase();
		}

	} else if (obj.query === &#x27;*&#x27;) {
		format = format + obj.coursePrefix.toUpperCase() + &quot;*&quot;;
	} else if (obj.query === &#x27;+&#x27;) {
		format = format + obj.coursePrefix.toUpperCase() + &quot; &quot;;
		format = format + obj.courseNumber.toString() + &quot;+&quot;;
	} else if (obj.query === &#x27;^&#x27;) {
		format = format + obj.school.toUpperCase() + &quot;^&quot;
	} else if (obj.query === &#x27;~&#x27;) {
		format = format + obj.category.toUpperCase() + &quot;~&quot;;
	} else if (obj.query === &#x27;$&#x27;) {
		format = format + obj.courseSuffix.toUpperCase() + &quot;$&quot;;
	}
	return format;
};

//goes through the queries in the array and removes 
//unneccessary elements in the Statement
//returns true if the Statement can be refactored and 
//returns false if the elements in the Statement contradict and
//the Statement is useless.  This is a facade method that calls 
//multiple other methods for refactoring different types 
//of queries
Statement.prototype.refactor = function() {
	var self = this;
	return this.refactorCollection.reduce(function(memo, funct) {
		//make sure to pass in the correct context to the function
		return memo &amp;&amp; funct.call(self);
	}, true);
	
};

//collection of functions that can be iterated and
//executed.  This is a collection of refactoring tests
//to run on the array object, that will automatically 
//be executed.  Each function must return true if the
//refactoring was successful, and false otherwise
Statement.prototype.refactorCollection = [
	//single courses
	function() {
		var singleCourses = this.tokens.filter(function(token) {return !token.query;}),
			i, n, j, representative;
		if (singleCourses.length &gt; 1) {
			for (i = 0, n = singleCourses.length; i &lt; n; ++i) {
				for (j = i + 1; j &lt; n; ++j) {
					if (!CourseCodeTokenizer.matchObject(singleCourses[i], singleCourses[j])) {
						return false;
					}
				}
			}
			//all courses are in agreement with one another at this point
			//get a single course to use as the replacement to the list of 
			//all single courses.  Remove any anti single courses
			singleCourses = singleCourses.filter(function(token) {
				return !token.not;
			});
			representative = (singleCourses.length) ? singleCourses[0] : null;
			//check if there is an single course that is positive to represent
			//courses
			if (representative) {
				this.tokens = this.tokens.filter(function(token) {
					return token.query || token === representative;
				});
			}
		}
		return true;
	},
	//check for any queries that are exclusively made of
	//anti queries
	function() {
		return this.tokens.length !== this.tokens.filter(function(token) {return token.not;}).length;
	},
	//compare a single course against all other queries
	function() {
		var i,n,
			singleTokens = this.tokens.filter(function(token) {
				return !token.not &amp;&amp; !token.query;
			}),
		//there should only be 1 single token since the single courses 
		//refactoring function was run before this
			singleToken = (singleTokens.length) ? singleTokens[0] : null;


		if (singleToken) {
			//compare the sinlge token to all other tokens
			for (i = 0, n = this.tokens.length; i &lt; n; ++i) {
				if (this.tokens[i] !== singleToken) {
					try {
						if (!CourseCodeTokenizer.matchObject(singleToken, this.tokens[i])) {
							return false;
						} else {
							this.tokens[i] = null;
						}
					} catch (e) {}
				}
			}
			this.tokens = this.tokens.filter(function(token) {return token;});
		}
		return true;
	},
	//start courses/ all courses in major
	function() {
		return true;
	}

]
//collection of queries that are related in some way,
//such as queries that satisfy a single course
//used to bundle queries and optimize processes
//such as matching courses to a set of queries 
//or unioning queries into 1
//takes an array of queries as a parameter
//parameter can either be an array of Statement objects
//or array of course code strings, but not a mix 
//of the two, throws an error if the parameter is not
//an array
function StatementCollection(statements) {
	if (!Array.isArray(statements)) {
		throw new Error(&quot;parameter for StatementCollection constructor should be an array&quot;);
	}
	if (statements.length === 0) {
		this.collection = [];
	} 

	else if (typeof statements[0] === &#x27;string&#x27;) {
		return new StatementCollection(statements.map(function(statementString) {return new Statement(statementString);}));
	}
	else if (statements[0].constructor === Statement) {
		
		this.collection = this.collapseStatements(statements);
		this.refactor();
	}
};

//returns true if the course code has
//the Statement collection
StatementCollection.prototype.has = function(courseCode) {
	var i, n;
	for (i = 0, n = this.collection.length; i &lt; n; ++i) {
		if (this.collection[i].has(courseCode)) {
			return true;
		}
	}
	return false;
};

//accepts an array of course codes and returns another array
//of course codes that satisfy the StatementCollection
StatementCollection.prototype.filter = function(courseCodes) {

	return courseCodes.filter(function(courseCode) {
		return this.has(courseCode);
	}, this).map(function(courseCode) {
		return Statement.formatStatement(courseCode);
	});
};

StatementCollection.prototype.copy = function() {
	return new StatementCollection(this.collection);
};


StatementCollection.prototype.toArray = function() {
	return this.collection.map(function(statement) {
		return statement.toString();
	});
};

//pass in either a string, Statement object
StatementCollection.prototype.append = function(statement) {
	var i, n;
	if (typeof statement === &#x27;string&#x27;) {
		this.append(new Statement(statement));
	} else if (statement.constructor === Statement) {
		if (statement.isNegated()) {
			for (i = 0, n = this.collection.length; i &lt; n; ++i) {
				this.collection[i].and(statement);
			}
		} else {
			this.collection.push(statement);
		}
	}
};

//for any unknown functionality...
StatementCollection.prototype.each = function(callback, context) {
	var _context = (context) ? context : this,
	i, n;

	for (i = 0, n = this.collection.length; i &lt; n; ++i) {
		callback.call(_context, this.collection[i], i);
	}
};

//Statement collection is unioned into the current Statement collection
StatementCollection.prototype.union = function(_collection) {
	var i, n, j,
	collection;
	if (this !== _collection) {
		if (Array.isArray(_collection)) {
			collection = new StatementCollection(_collection);
		}
		else if (_collection.constructor === StatementCollection) {
			collection = _collection
		}

		collection.each(function(statement) {
			this.collection.push(statement.copy());
		}, this);

		for (i = 0, n = this.collection.length; i &lt; n; ++i) {
			if (this.collection[i]) {
				for (j = i + 1; j &lt; n; ++j) {
					
					if (this.collection[j] &amp;&amp; this.collection[i].isEqual(this.collection[j])) {
						this.collection[j] = null;
					}
				}
			}
				
		}
		//filter out the nulled elements
		this.collection = this.collection.filter(function(statement) {
			return statement;
		});
	}		
};

//static methods
StatementCollection.union = function(collection1, collection2) {
	var queries = null;

	
	//collection 1 and 2 both have values in it
	if (Array.isArray(collection1) &amp;&amp; typeof collection1[0] === &#x27;string&#x27;) {
		queries = new StatementCollection(collection1);
			
	} else if (collection1.constructor === StatementCollection) {
		queries = collection1;
	}

	queries.union(collection2);
	
	return queries;
};

//methods that should be &quot;private&quot;

//takes an array of Statement objects
StatementCollection.prototype.collapseStatements = function(statements) {
	//make a copy of the queries so that they are not changed
	var i, j, n, _statements = statements.slice();

	for (i = 0, n = _statements.length; i &lt; n; ++i) {
		if (_statements[i].isNegated()) {
			for (j = i - 1; j &gt;= 0; --j) {
				_statements[j].and(_statements[i].toString());
			}
		}
	}
	return _statements.filter(function(statement) {
		return !statement.isNegated();
	});
	
};

//attempts to refactor the Statement but if there is a conflict, this method
//will simply return false, returns true if no conflict was found and
//refactoring was successful
StatementCollection.prototype.refactor = function() {
	this.collection = this.collection.filter(function(statement) {
		//each Statement performs its own refactoring and returns false
		//if conflicts are found, so Statement must be removed
		return statement.refactor();
	});
};


//set the exports for server side script
if (serverSide) {
	exports.CourseCodeTokenizer = CourseCodeTokenizer;
	exports.Statement = Statement,
	exports.StatementCollection = StatementCollection;
} 




    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
